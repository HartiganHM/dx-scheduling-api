module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Address {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  street: String!
  city: String!
  state: String!
  zip: String!
}

type AddressConnection {
  pageInfo: PageInfo!
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

input AddressCreateInput {
  street: String!
  city: String!
  state: String!
  zip: String!
}

input AddressCreateOneInput {
  create: AddressCreateInput
  connect: AddressWhereUniqueInput
}

type AddressEdge {
  node: Address!
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  street_ASC
  street_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  zip_ASC
  zip_DESC
}

type AddressPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  street: String!
  city: String!
  state: String!
  zip: String!
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
  AND: [AddressSubscriptionWhereInput!]
  OR: [AddressSubscriptionWhereInput!]
  NOT: [AddressSubscriptionWhereInput!]
}

input AddressUpdateDataInput {
  street: String
  city: String
  state: String
  zip: String
}

input AddressUpdateInput {
  street: String
  city: String
  state: String
  zip: String
}

input AddressUpdateManyMutationInput {
  street: String
  city: String
  state: String
  zip: String
}

input AddressUpdateOneRequiredInput {
  create: AddressCreateInput
  update: AddressUpdateDataInput
  upsert: AddressUpsertNestedInput
  connect: AddressWhereUniqueInput
}

input AddressUpsertNestedInput {
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  street: String
  street_not: String
  street_in: [String!]
  street_not_in: [String!]
  street_lt: String
  street_lte: String
  street_gt: String
  street_gte: String
  street_contains: String
  street_not_contains: String
  street_starts_with: String
  street_not_starts_with: String
  street_ends_with: String
  street_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  zip: String
  zip_not: String
  zip_in: [String!]
  zip_not_in: [String!]
  zip_lt: String
  zip_lte: String
  zip_gt: String
  zip_gte: String
  zip_contains: String
  zip_not_contains: String
  zip_starts_with: String
  zip_not_starts_with: String
  zip_ends_with: String
  zip_not_ends_with: String
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddress {
  count: Int!
}

type AggregateClient {
  count: Int!
}

type AggregateClientIntake {
  count: Int!
}

type AggregateConcerns {
  count: Int!
}

type AggregateDiagnosis {
  count: Int!
}

type AggregateInsurance {
  count: Int!
}

type AggregateIntakeFormQuestions {
  count: Int!
}

type AggregateIntakeFormValues {
  count: Int!
}

type AggregateParent {
  count: Int!
}

type AggregatePermission {
  count: Int!
}

type AggregatePhysician {
  count: Int!
}

type AggregateReferral {
  count: Int!
}

type AggregateRole {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Client {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  dob: String!
  gender: String!
  school: String!
  grade: String!
  parents(where: ParentWhereInput, orderBy: ParentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Parent!]
  insurances(where: InsuranceWhereInput, orderBy: InsuranceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Insurance!]
  physician: Physician!
}

type ClientConnection {
  pageInfo: PageInfo!
  edges: [ClientEdge]!
  aggregate: AggregateClient!
}

input ClientCreateInput {
  firstName: String!
  lastName: String!
  dob: String!
  gender: String!
  school: String!
  grade: String!
  parents: ParentCreateManyInput
  insurances: InsuranceCreateManyInput
  physician: PhysicianCreateOneInput!
}

input ClientCreateOneInput {
  create: ClientCreateInput
  connect: ClientWhereUniqueInput
}

type ClientEdge {
  node: Client!
  cursor: String!
}

type ClientIntake {
  id: ID!
  intakeFormValues: IntakeFormValues!
  intakeFormQuestions: IntakeFormQuestions!
}

type ClientIntakeConnection {
  pageInfo: PageInfo!
  edges: [ClientIntakeEdge]!
  aggregate: AggregateClientIntake!
}

input ClientIntakeCreateInput {
  intakeFormValues: IntakeFormValuesCreateOneInput!
  intakeFormQuestions: IntakeFormQuestionsCreateOneInput!
}

type ClientIntakeEdge {
  node: ClientIntake!
  cursor: String!
}

enum ClientIntakeOrderByInput {
  id_ASC
  id_DESC
}

type ClientIntakePreviousValues {
  id: ID!
}

type ClientIntakeSubscriptionPayload {
  mutation: MutationType!
  node: ClientIntake
  updatedFields: [String!]
  previousValues: ClientIntakePreviousValues
}

input ClientIntakeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClientIntakeWhereInput
  AND: [ClientIntakeSubscriptionWhereInput!]
  OR: [ClientIntakeSubscriptionWhereInput!]
  NOT: [ClientIntakeSubscriptionWhereInput!]
}

input ClientIntakeUpdateInput {
  intakeFormValues: IntakeFormValuesUpdateOneRequiredInput
  intakeFormQuestions: IntakeFormQuestionsUpdateOneRequiredInput
}

input ClientIntakeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  intakeFormValues: IntakeFormValuesWhereInput
  intakeFormQuestions: IntakeFormQuestionsWhereInput
  AND: [ClientIntakeWhereInput!]
  OR: [ClientIntakeWhereInput!]
  NOT: [ClientIntakeWhereInput!]
}

input ClientIntakeWhereUniqueInput {
  id: ID
}

enum ClientOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  dob_ASC
  dob_DESC
  gender_ASC
  gender_DESC
  school_ASC
  school_DESC
  grade_ASC
  grade_DESC
}

type ClientPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  dob: String!
  gender: String!
  school: String!
  grade: String!
}

type ClientSubscriptionPayload {
  mutation: MutationType!
  node: Client
  updatedFields: [String!]
  previousValues: ClientPreviousValues
}

input ClientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClientWhereInput
  AND: [ClientSubscriptionWhereInput!]
  OR: [ClientSubscriptionWhereInput!]
  NOT: [ClientSubscriptionWhereInput!]
}

input ClientUpdateDataInput {
  firstName: String
  lastName: String
  dob: String
  gender: String
  school: String
  grade: String
  parents: ParentUpdateManyInput
  insurances: InsuranceUpdateManyInput
  physician: PhysicianUpdateOneRequiredInput
}

input ClientUpdateInput {
  firstName: String
  lastName: String
  dob: String
  gender: String
  school: String
  grade: String
  parents: ParentUpdateManyInput
  insurances: InsuranceUpdateManyInput
  physician: PhysicianUpdateOneRequiredInput
}

input ClientUpdateManyMutationInput {
  firstName: String
  lastName: String
  dob: String
  gender: String
  school: String
  grade: String
}

input ClientUpdateOneRequiredInput {
  create: ClientCreateInput
  update: ClientUpdateDataInput
  upsert: ClientUpsertNestedInput
  connect: ClientWhereUniqueInput
}

input ClientUpsertNestedInput {
  update: ClientUpdateDataInput!
  create: ClientCreateInput!
}

input ClientWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  dob: String
  dob_not: String
  dob_in: [String!]
  dob_not_in: [String!]
  dob_lt: String
  dob_lte: String
  dob_gt: String
  dob_gte: String
  dob_contains: String
  dob_not_contains: String
  dob_starts_with: String
  dob_not_starts_with: String
  dob_ends_with: String
  dob_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  school: String
  school_not: String
  school_in: [String!]
  school_not_in: [String!]
  school_lt: String
  school_lte: String
  school_gt: String
  school_gte: String
  school_contains: String
  school_not_contains: String
  school_starts_with: String
  school_not_starts_with: String
  school_ends_with: String
  school_not_ends_with: String
  grade: String
  grade_not: String
  grade_in: [String!]
  grade_not_in: [String!]
  grade_lt: String
  grade_lte: String
  grade_gt: String
  grade_gte: String
  grade_contains: String
  grade_not_contains: String
  grade_starts_with: String
  grade_not_starts_with: String
  grade_ends_with: String
  grade_not_ends_with: String
  parents_every: ParentWhereInput
  parents_some: ParentWhereInput
  parents_none: ParentWhereInput
  insurances_every: InsuranceWhereInput
  insurances_some: InsuranceWhereInput
  insurances_none: InsuranceWhereInput
  physician: PhysicianWhereInput
  AND: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  NOT: [ClientWhereInput!]
}

input ClientWhereUniqueInput {
  id: ID
}

type Concerns {
  id: ID!
  areas: String!
  communication: String!
  motor: String!
  sensory: String!
  cognitive: String!
}

type ConcernsConnection {
  pageInfo: PageInfo!
  edges: [ConcernsEdge]!
  aggregate: AggregateConcerns!
}

input ConcernsCreateInput {
  areas: String!
  communication: String!
  motor: String!
  sensory: String!
  cognitive: String!
}

input ConcernsCreateOneInput {
  create: ConcernsCreateInput
  connect: ConcernsWhereUniqueInput
}

type ConcernsEdge {
  node: Concerns!
  cursor: String!
}

enum ConcernsOrderByInput {
  id_ASC
  id_DESC
  areas_ASC
  areas_DESC
  communication_ASC
  communication_DESC
  motor_ASC
  motor_DESC
  sensory_ASC
  sensory_DESC
  cognitive_ASC
  cognitive_DESC
}

type ConcernsPreviousValues {
  id: ID!
  areas: String!
  communication: String!
  motor: String!
  sensory: String!
  cognitive: String!
}

type ConcernsSubscriptionPayload {
  mutation: MutationType!
  node: Concerns
  updatedFields: [String!]
  previousValues: ConcernsPreviousValues
}

input ConcernsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConcernsWhereInput
  AND: [ConcernsSubscriptionWhereInput!]
  OR: [ConcernsSubscriptionWhereInput!]
  NOT: [ConcernsSubscriptionWhereInput!]
}

input ConcernsUpdateDataInput {
  areas: String
  communication: String
  motor: String
  sensory: String
  cognitive: String
}

input ConcernsUpdateInput {
  areas: String
  communication: String
  motor: String
  sensory: String
  cognitive: String
}

input ConcernsUpdateManyMutationInput {
  areas: String
  communication: String
  motor: String
  sensory: String
  cognitive: String
}

input ConcernsUpdateOneRequiredInput {
  create: ConcernsCreateInput
  update: ConcernsUpdateDataInput
  upsert: ConcernsUpsertNestedInput
  connect: ConcernsWhereUniqueInput
}

input ConcernsUpsertNestedInput {
  update: ConcernsUpdateDataInput!
  create: ConcernsCreateInput!
}

input ConcernsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  areas: String
  areas_not: String
  areas_in: [String!]
  areas_not_in: [String!]
  areas_lt: String
  areas_lte: String
  areas_gt: String
  areas_gte: String
  areas_contains: String
  areas_not_contains: String
  areas_starts_with: String
  areas_not_starts_with: String
  areas_ends_with: String
  areas_not_ends_with: String
  communication: String
  communication_not: String
  communication_in: [String!]
  communication_not_in: [String!]
  communication_lt: String
  communication_lte: String
  communication_gt: String
  communication_gte: String
  communication_contains: String
  communication_not_contains: String
  communication_starts_with: String
  communication_not_starts_with: String
  communication_ends_with: String
  communication_not_ends_with: String
  motor: String
  motor_not: String
  motor_in: [String!]
  motor_not_in: [String!]
  motor_lt: String
  motor_lte: String
  motor_gt: String
  motor_gte: String
  motor_contains: String
  motor_not_contains: String
  motor_starts_with: String
  motor_not_starts_with: String
  motor_ends_with: String
  motor_not_ends_with: String
  sensory: String
  sensory_not: String
  sensory_in: [String!]
  sensory_not_in: [String!]
  sensory_lt: String
  sensory_lte: String
  sensory_gt: String
  sensory_gte: String
  sensory_contains: String
  sensory_not_contains: String
  sensory_starts_with: String
  sensory_not_starts_with: String
  sensory_ends_with: String
  sensory_not_ends_with: String
  cognitive: String
  cognitive_not: String
  cognitive_in: [String!]
  cognitive_not_in: [String!]
  cognitive_lt: String
  cognitive_lte: String
  cognitive_gt: String
  cognitive_gte: String
  cognitive_contains: String
  cognitive_not_contains: String
  cognitive_starts_with: String
  cognitive_not_starts_with: String
  cognitive_ends_with: String
  cognitive_not_ends_with: String
  AND: [ConcernsWhereInput!]
  OR: [ConcernsWhereInput!]
  NOT: [ConcernsWhereInput!]
}

input ConcernsWhereUniqueInput {
  id: ID
}

scalar DateTime

type Diagnosis {
  id: ID!
  name: String!
  provider: String!
  data: String!
  comments: String!
}

type DiagnosisConnection {
  pageInfo: PageInfo!
  edges: [DiagnosisEdge]!
  aggregate: AggregateDiagnosis!
}

input DiagnosisCreateInput {
  name: String!
  provider: String!
  data: String!
  comments: String!
}

input DiagnosisCreateOneInput {
  create: DiagnosisCreateInput
  connect: DiagnosisWhereUniqueInput
}

type DiagnosisEdge {
  node: Diagnosis!
  cursor: String!
}

enum DiagnosisOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  provider_ASC
  provider_DESC
  data_ASC
  data_DESC
  comments_ASC
  comments_DESC
}

type DiagnosisPreviousValues {
  id: ID!
  name: String!
  provider: String!
  data: String!
  comments: String!
}

type DiagnosisSubscriptionPayload {
  mutation: MutationType!
  node: Diagnosis
  updatedFields: [String!]
  previousValues: DiagnosisPreviousValues
}

input DiagnosisSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DiagnosisWhereInput
  AND: [DiagnosisSubscriptionWhereInput!]
  OR: [DiagnosisSubscriptionWhereInput!]
  NOT: [DiagnosisSubscriptionWhereInput!]
}

input DiagnosisUpdateDataInput {
  name: String
  provider: String
  data: String
  comments: String
}

input DiagnosisUpdateInput {
  name: String
  provider: String
  data: String
  comments: String
}

input DiagnosisUpdateManyMutationInput {
  name: String
  provider: String
  data: String
  comments: String
}

input DiagnosisUpdateOneRequiredInput {
  create: DiagnosisCreateInput
  update: DiagnosisUpdateDataInput
  upsert: DiagnosisUpsertNestedInput
  connect: DiagnosisWhereUniqueInput
}

input DiagnosisUpsertNestedInput {
  update: DiagnosisUpdateDataInput!
  create: DiagnosisCreateInput!
}

input DiagnosisWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  provider: String
  provider_not: String
  provider_in: [String!]
  provider_not_in: [String!]
  provider_lt: String
  provider_lte: String
  provider_gt: String
  provider_gte: String
  provider_contains: String
  provider_not_contains: String
  provider_starts_with: String
  provider_not_starts_with: String
  provider_ends_with: String
  provider_not_ends_with: String
  data: String
  data_not: String
  data_in: [String!]
  data_not_in: [String!]
  data_lt: String
  data_lte: String
  data_gt: String
  data_gte: String
  data_contains: String
  data_not_contains: String
  data_starts_with: String
  data_not_starts_with: String
  data_ends_with: String
  data_not_ends_with: String
  comments: String
  comments_not: String
  comments_in: [String!]
  comments_not_in: [String!]
  comments_lt: String
  comments_lte: String
  comments_gt: String
  comments_gte: String
  comments_contains: String
  comments_not_contains: String
  comments_starts_with: String
  comments_not_starts_with: String
  comments_ends_with: String
  comments_not_ends_with: String
  AND: [DiagnosisWhereInput!]
  OR: [DiagnosisWhereInput!]
  NOT: [DiagnosisWhereInput!]
}

input DiagnosisWhereUniqueInput {
  id: ID
}

type Insurance {
  id: ID!
  idNumber: String!
  groupNumber: String!
  provider: String!
  insured: String!
}

type InsuranceConnection {
  pageInfo: PageInfo!
  edges: [InsuranceEdge]!
  aggregate: AggregateInsurance!
}

input InsuranceCreateInput {
  idNumber: String!
  groupNumber: String!
  provider: String!
  insured: String!
}

input InsuranceCreateManyInput {
  create: [InsuranceCreateInput!]
  connect: [InsuranceWhereUniqueInput!]
}

type InsuranceEdge {
  node: Insurance!
  cursor: String!
}

enum InsuranceOrderByInput {
  id_ASC
  id_DESC
  idNumber_ASC
  idNumber_DESC
  groupNumber_ASC
  groupNumber_DESC
  provider_ASC
  provider_DESC
  insured_ASC
  insured_DESC
}

type InsurancePreviousValues {
  id: ID!
  idNumber: String!
  groupNumber: String!
  provider: String!
  insured: String!
}

input InsuranceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  idNumber: String
  idNumber_not: String
  idNumber_in: [String!]
  idNumber_not_in: [String!]
  idNumber_lt: String
  idNumber_lte: String
  idNumber_gt: String
  idNumber_gte: String
  idNumber_contains: String
  idNumber_not_contains: String
  idNumber_starts_with: String
  idNumber_not_starts_with: String
  idNumber_ends_with: String
  idNumber_not_ends_with: String
  groupNumber: String
  groupNumber_not: String
  groupNumber_in: [String!]
  groupNumber_not_in: [String!]
  groupNumber_lt: String
  groupNumber_lte: String
  groupNumber_gt: String
  groupNumber_gte: String
  groupNumber_contains: String
  groupNumber_not_contains: String
  groupNumber_starts_with: String
  groupNumber_not_starts_with: String
  groupNumber_ends_with: String
  groupNumber_not_ends_with: String
  provider: String
  provider_not: String
  provider_in: [String!]
  provider_not_in: [String!]
  provider_lt: String
  provider_lte: String
  provider_gt: String
  provider_gte: String
  provider_contains: String
  provider_not_contains: String
  provider_starts_with: String
  provider_not_starts_with: String
  provider_ends_with: String
  provider_not_ends_with: String
  insured: String
  insured_not: String
  insured_in: [String!]
  insured_not_in: [String!]
  insured_lt: String
  insured_lte: String
  insured_gt: String
  insured_gte: String
  insured_contains: String
  insured_not_contains: String
  insured_starts_with: String
  insured_not_starts_with: String
  insured_ends_with: String
  insured_not_ends_with: String
  AND: [InsuranceScalarWhereInput!]
  OR: [InsuranceScalarWhereInput!]
  NOT: [InsuranceScalarWhereInput!]
}

type InsuranceSubscriptionPayload {
  mutation: MutationType!
  node: Insurance
  updatedFields: [String!]
  previousValues: InsurancePreviousValues
}

input InsuranceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InsuranceWhereInput
  AND: [InsuranceSubscriptionWhereInput!]
  OR: [InsuranceSubscriptionWhereInput!]
  NOT: [InsuranceSubscriptionWhereInput!]
}

input InsuranceUpdateDataInput {
  idNumber: String
  groupNumber: String
  provider: String
  insured: String
}

input InsuranceUpdateInput {
  idNumber: String
  groupNumber: String
  provider: String
  insured: String
}

input InsuranceUpdateManyDataInput {
  idNumber: String
  groupNumber: String
  provider: String
  insured: String
}

input InsuranceUpdateManyInput {
  create: [InsuranceCreateInput!]
  update: [InsuranceUpdateWithWhereUniqueNestedInput!]
  upsert: [InsuranceUpsertWithWhereUniqueNestedInput!]
  delete: [InsuranceWhereUniqueInput!]
  connect: [InsuranceWhereUniqueInput!]
  set: [InsuranceWhereUniqueInput!]
  disconnect: [InsuranceWhereUniqueInput!]
  deleteMany: [InsuranceScalarWhereInput!]
  updateMany: [InsuranceUpdateManyWithWhereNestedInput!]
}

input InsuranceUpdateManyMutationInput {
  idNumber: String
  groupNumber: String
  provider: String
  insured: String
}

input InsuranceUpdateManyWithWhereNestedInput {
  where: InsuranceScalarWhereInput!
  data: InsuranceUpdateManyDataInput!
}

input InsuranceUpdateWithWhereUniqueNestedInput {
  where: InsuranceWhereUniqueInput!
  data: InsuranceUpdateDataInput!
}

input InsuranceUpsertWithWhereUniqueNestedInput {
  where: InsuranceWhereUniqueInput!
  update: InsuranceUpdateDataInput!
  create: InsuranceCreateInput!
}

input InsuranceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  idNumber: String
  idNumber_not: String
  idNumber_in: [String!]
  idNumber_not_in: [String!]
  idNumber_lt: String
  idNumber_lte: String
  idNumber_gt: String
  idNumber_gte: String
  idNumber_contains: String
  idNumber_not_contains: String
  idNumber_starts_with: String
  idNumber_not_starts_with: String
  idNumber_ends_with: String
  idNumber_not_ends_with: String
  groupNumber: String
  groupNumber_not: String
  groupNumber_in: [String!]
  groupNumber_not_in: [String!]
  groupNumber_lt: String
  groupNumber_lte: String
  groupNumber_gt: String
  groupNumber_gte: String
  groupNumber_contains: String
  groupNumber_not_contains: String
  groupNumber_starts_with: String
  groupNumber_not_starts_with: String
  groupNumber_ends_with: String
  groupNumber_not_ends_with: String
  provider: String
  provider_not: String
  provider_in: [String!]
  provider_not_in: [String!]
  provider_lt: String
  provider_lte: String
  provider_gt: String
  provider_gte: String
  provider_contains: String
  provider_not_contains: String
  provider_starts_with: String
  provider_not_starts_with: String
  provider_ends_with: String
  provider_not_ends_with: String
  insured: String
  insured_not: String
  insured_in: [String!]
  insured_not_in: [String!]
  insured_lt: String
  insured_lte: String
  insured_gt: String
  insured_gte: String
  insured_contains: String
  insured_not_contains: String
  insured_starts_with: String
  insured_not_starts_with: String
  insured_ends_with: String
  insured_not_ends_with: String
  AND: [InsuranceWhereInput!]
  OR: [InsuranceWhereInput!]
  NOT: [InsuranceWhereInput!]
}

input InsuranceWhereUniqueInput {
  id: ID
}

type IntakeFormQuestions {
  id: ID!
  creditCardInfoSaved: Boolean!
  ratesDiscussed: Boolean!
  preferredTimes: Boolean!
  needs: String!
  hasReferral: Boolean!
  priorTherapy: String!
  schoolSupport: String!
  priorTreatments: String!
  referral: Referral
  referralConcernMatch: String
  diagnosis: Diagnosis!
  concerns: Concerns!
}

type IntakeFormQuestionsConnection {
  pageInfo: PageInfo!
  edges: [IntakeFormQuestionsEdge]!
  aggregate: AggregateIntakeFormQuestions!
}

input IntakeFormQuestionsCreateInput {
  creditCardInfoSaved: Boolean!
  ratesDiscussed: Boolean!
  preferredTimes: Boolean!
  needs: String!
  hasReferral: Boolean!
  priorTherapy: String!
  schoolSupport: String!
  priorTreatments: String!
  referral: ReferralCreateOneInput
  referralConcernMatch: String
  diagnosis: DiagnosisCreateOneInput!
  concerns: ConcernsCreateOneInput!
}

input IntakeFormQuestionsCreateOneInput {
  create: IntakeFormQuestionsCreateInput
  connect: IntakeFormQuestionsWhereUniqueInput
}

type IntakeFormQuestionsEdge {
  node: IntakeFormQuestions!
  cursor: String!
}

enum IntakeFormQuestionsOrderByInput {
  id_ASC
  id_DESC
  creditCardInfoSaved_ASC
  creditCardInfoSaved_DESC
  ratesDiscussed_ASC
  ratesDiscussed_DESC
  preferredTimes_ASC
  preferredTimes_DESC
  needs_ASC
  needs_DESC
  hasReferral_ASC
  hasReferral_DESC
  priorTherapy_ASC
  priorTherapy_DESC
  schoolSupport_ASC
  schoolSupport_DESC
  priorTreatments_ASC
  priorTreatments_DESC
  referralConcernMatch_ASC
  referralConcernMatch_DESC
}

type IntakeFormQuestionsPreviousValues {
  id: ID!
  creditCardInfoSaved: Boolean!
  ratesDiscussed: Boolean!
  preferredTimes: Boolean!
  needs: String!
  hasReferral: Boolean!
  priorTherapy: String!
  schoolSupport: String!
  priorTreatments: String!
  referralConcernMatch: String
}

type IntakeFormQuestionsSubscriptionPayload {
  mutation: MutationType!
  node: IntakeFormQuestions
  updatedFields: [String!]
  previousValues: IntakeFormQuestionsPreviousValues
}

input IntakeFormQuestionsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IntakeFormQuestionsWhereInput
  AND: [IntakeFormQuestionsSubscriptionWhereInput!]
  OR: [IntakeFormQuestionsSubscriptionWhereInput!]
  NOT: [IntakeFormQuestionsSubscriptionWhereInput!]
}

input IntakeFormQuestionsUpdateDataInput {
  creditCardInfoSaved: Boolean
  ratesDiscussed: Boolean
  preferredTimes: Boolean
  needs: String
  hasReferral: Boolean
  priorTherapy: String
  schoolSupport: String
  priorTreatments: String
  referral: ReferralUpdateOneInput
  referralConcernMatch: String
  diagnosis: DiagnosisUpdateOneRequiredInput
  concerns: ConcernsUpdateOneRequiredInput
}

input IntakeFormQuestionsUpdateInput {
  creditCardInfoSaved: Boolean
  ratesDiscussed: Boolean
  preferredTimes: Boolean
  needs: String
  hasReferral: Boolean
  priorTherapy: String
  schoolSupport: String
  priorTreatments: String
  referral: ReferralUpdateOneInput
  referralConcernMatch: String
  diagnosis: DiagnosisUpdateOneRequiredInput
  concerns: ConcernsUpdateOneRequiredInput
}

input IntakeFormQuestionsUpdateManyMutationInput {
  creditCardInfoSaved: Boolean
  ratesDiscussed: Boolean
  preferredTimes: Boolean
  needs: String
  hasReferral: Boolean
  priorTherapy: String
  schoolSupport: String
  priorTreatments: String
  referralConcernMatch: String
}

input IntakeFormQuestionsUpdateOneRequiredInput {
  create: IntakeFormQuestionsCreateInput
  update: IntakeFormQuestionsUpdateDataInput
  upsert: IntakeFormQuestionsUpsertNestedInput
  connect: IntakeFormQuestionsWhereUniqueInput
}

input IntakeFormQuestionsUpsertNestedInput {
  update: IntakeFormQuestionsUpdateDataInput!
  create: IntakeFormQuestionsCreateInput!
}

input IntakeFormQuestionsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  creditCardInfoSaved: Boolean
  creditCardInfoSaved_not: Boolean
  ratesDiscussed: Boolean
  ratesDiscussed_not: Boolean
  preferredTimes: Boolean
  preferredTimes_not: Boolean
  needs: String
  needs_not: String
  needs_in: [String!]
  needs_not_in: [String!]
  needs_lt: String
  needs_lte: String
  needs_gt: String
  needs_gte: String
  needs_contains: String
  needs_not_contains: String
  needs_starts_with: String
  needs_not_starts_with: String
  needs_ends_with: String
  needs_not_ends_with: String
  hasReferral: Boolean
  hasReferral_not: Boolean
  priorTherapy: String
  priorTherapy_not: String
  priorTherapy_in: [String!]
  priorTherapy_not_in: [String!]
  priorTherapy_lt: String
  priorTherapy_lte: String
  priorTherapy_gt: String
  priorTherapy_gte: String
  priorTherapy_contains: String
  priorTherapy_not_contains: String
  priorTherapy_starts_with: String
  priorTherapy_not_starts_with: String
  priorTherapy_ends_with: String
  priorTherapy_not_ends_with: String
  schoolSupport: String
  schoolSupport_not: String
  schoolSupport_in: [String!]
  schoolSupport_not_in: [String!]
  schoolSupport_lt: String
  schoolSupport_lte: String
  schoolSupport_gt: String
  schoolSupport_gte: String
  schoolSupport_contains: String
  schoolSupport_not_contains: String
  schoolSupport_starts_with: String
  schoolSupport_not_starts_with: String
  schoolSupport_ends_with: String
  schoolSupport_not_ends_with: String
  priorTreatments: String
  priorTreatments_not: String
  priorTreatments_in: [String!]
  priorTreatments_not_in: [String!]
  priorTreatments_lt: String
  priorTreatments_lte: String
  priorTreatments_gt: String
  priorTreatments_gte: String
  priorTreatments_contains: String
  priorTreatments_not_contains: String
  priorTreatments_starts_with: String
  priorTreatments_not_starts_with: String
  priorTreatments_ends_with: String
  priorTreatments_not_ends_with: String
  referral: ReferralWhereInput
  referralConcernMatch: String
  referralConcernMatch_not: String
  referralConcernMatch_in: [String!]
  referralConcernMatch_not_in: [String!]
  referralConcernMatch_lt: String
  referralConcernMatch_lte: String
  referralConcernMatch_gt: String
  referralConcernMatch_gte: String
  referralConcernMatch_contains: String
  referralConcernMatch_not_contains: String
  referralConcernMatch_starts_with: String
  referralConcernMatch_not_starts_with: String
  referralConcernMatch_ends_with: String
  referralConcernMatch_not_ends_with: String
  diagnosis: DiagnosisWhereInput
  concerns: ConcernsWhereInput
  AND: [IntakeFormQuestionsWhereInput!]
  OR: [IntakeFormQuestionsWhereInput!]
  NOT: [IntakeFormQuestionsWhereInput!]
}

input IntakeFormQuestionsWhereUniqueInput {
  id: ID
}

type IntakeFormValues {
  id: ID!
  date: String!
  servicesRequested: [String!]!
  client: Client!
}

type IntakeFormValuesConnection {
  pageInfo: PageInfo!
  edges: [IntakeFormValuesEdge]!
  aggregate: AggregateIntakeFormValues!
}

input IntakeFormValuesCreateInput {
  date: String!
  servicesRequested: IntakeFormValuesCreateservicesRequestedInput
  client: ClientCreateOneInput!
}

input IntakeFormValuesCreateOneInput {
  create: IntakeFormValuesCreateInput
  connect: IntakeFormValuesWhereUniqueInput
}

input IntakeFormValuesCreateservicesRequestedInput {
  set: [String!]
}

type IntakeFormValuesEdge {
  node: IntakeFormValues!
  cursor: String!
}

enum IntakeFormValuesOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
}

type IntakeFormValuesPreviousValues {
  id: ID!
  date: String!
  servicesRequested: [String!]!
}

type IntakeFormValuesSubscriptionPayload {
  mutation: MutationType!
  node: IntakeFormValues
  updatedFields: [String!]
  previousValues: IntakeFormValuesPreviousValues
}

input IntakeFormValuesSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IntakeFormValuesWhereInput
  AND: [IntakeFormValuesSubscriptionWhereInput!]
  OR: [IntakeFormValuesSubscriptionWhereInput!]
  NOT: [IntakeFormValuesSubscriptionWhereInput!]
}

input IntakeFormValuesUpdateDataInput {
  date: String
  servicesRequested: IntakeFormValuesUpdateservicesRequestedInput
  client: ClientUpdateOneRequiredInput
}

input IntakeFormValuesUpdateInput {
  date: String
  servicesRequested: IntakeFormValuesUpdateservicesRequestedInput
  client: ClientUpdateOneRequiredInput
}

input IntakeFormValuesUpdateManyMutationInput {
  date: String
  servicesRequested: IntakeFormValuesUpdateservicesRequestedInput
}

input IntakeFormValuesUpdateOneRequiredInput {
  create: IntakeFormValuesCreateInput
  update: IntakeFormValuesUpdateDataInput
  upsert: IntakeFormValuesUpsertNestedInput
  connect: IntakeFormValuesWhereUniqueInput
}

input IntakeFormValuesUpdateservicesRequestedInput {
  set: [String!]
}

input IntakeFormValuesUpsertNestedInput {
  update: IntakeFormValuesUpdateDataInput!
  create: IntakeFormValuesCreateInput!
}

input IntakeFormValuesWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  client: ClientWhereInput
  AND: [IntakeFormValuesWhereInput!]
  OR: [IntakeFormValuesWhereInput!]
  NOT: [IntakeFormValuesWhereInput!]
}

input IntakeFormValuesWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAddress(data: AddressCreateInput!): Address!
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  upsertAddress(where: AddressWhereUniqueInput!, create: AddressCreateInput!, update: AddressUpdateInput!): Address!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  createClient(data: ClientCreateInput!): Client!
  updateClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateManyClients(data: ClientUpdateManyMutationInput!, where: ClientWhereInput): BatchPayload!
  upsertClient(where: ClientWhereUniqueInput!, create: ClientCreateInput!, update: ClientUpdateInput!): Client!
  deleteClient(where: ClientWhereUniqueInput!): Client
  deleteManyClients(where: ClientWhereInput): BatchPayload!
  createClientIntake(data: ClientIntakeCreateInput!): ClientIntake!
  updateClientIntake(data: ClientIntakeUpdateInput!, where: ClientIntakeWhereUniqueInput!): ClientIntake
  upsertClientIntake(where: ClientIntakeWhereUniqueInput!, create: ClientIntakeCreateInput!, update: ClientIntakeUpdateInput!): ClientIntake!
  deleteClientIntake(where: ClientIntakeWhereUniqueInput!): ClientIntake
  deleteManyClientIntakes(where: ClientIntakeWhereInput): BatchPayload!
  createConcerns(data: ConcernsCreateInput!): Concerns!
  updateConcerns(data: ConcernsUpdateInput!, where: ConcernsWhereUniqueInput!): Concerns
  updateManyConcernses(data: ConcernsUpdateManyMutationInput!, where: ConcernsWhereInput): BatchPayload!
  upsertConcerns(where: ConcernsWhereUniqueInput!, create: ConcernsCreateInput!, update: ConcernsUpdateInput!): Concerns!
  deleteConcerns(where: ConcernsWhereUniqueInput!): Concerns
  deleteManyConcernses(where: ConcernsWhereInput): BatchPayload!
  createDiagnosis(data: DiagnosisCreateInput!): Diagnosis!
  updateDiagnosis(data: DiagnosisUpdateInput!, where: DiagnosisWhereUniqueInput!): Diagnosis
  updateManyDiagnoses(data: DiagnosisUpdateManyMutationInput!, where: DiagnosisWhereInput): BatchPayload!
  upsertDiagnosis(where: DiagnosisWhereUniqueInput!, create: DiagnosisCreateInput!, update: DiagnosisUpdateInput!): Diagnosis!
  deleteDiagnosis(where: DiagnosisWhereUniqueInput!): Diagnosis
  deleteManyDiagnoses(where: DiagnosisWhereInput): BatchPayload!
  createInsurance(data: InsuranceCreateInput!): Insurance!
  updateInsurance(data: InsuranceUpdateInput!, where: InsuranceWhereUniqueInput!): Insurance
  updateManyInsurances(data: InsuranceUpdateManyMutationInput!, where: InsuranceWhereInput): BatchPayload!
  upsertInsurance(where: InsuranceWhereUniqueInput!, create: InsuranceCreateInput!, update: InsuranceUpdateInput!): Insurance!
  deleteInsurance(where: InsuranceWhereUniqueInput!): Insurance
  deleteManyInsurances(where: InsuranceWhereInput): BatchPayload!
  createIntakeFormQuestions(data: IntakeFormQuestionsCreateInput!): IntakeFormQuestions!
  updateIntakeFormQuestions(data: IntakeFormQuestionsUpdateInput!, where: IntakeFormQuestionsWhereUniqueInput!): IntakeFormQuestions
  updateManyIntakeFormQuestionses(data: IntakeFormQuestionsUpdateManyMutationInput!, where: IntakeFormQuestionsWhereInput): BatchPayload!
  upsertIntakeFormQuestions(where: IntakeFormQuestionsWhereUniqueInput!, create: IntakeFormQuestionsCreateInput!, update: IntakeFormQuestionsUpdateInput!): IntakeFormQuestions!
  deleteIntakeFormQuestions(where: IntakeFormQuestionsWhereUniqueInput!): IntakeFormQuestions
  deleteManyIntakeFormQuestionses(where: IntakeFormQuestionsWhereInput): BatchPayload!
  createIntakeFormValues(data: IntakeFormValuesCreateInput!): IntakeFormValues!
  updateIntakeFormValues(data: IntakeFormValuesUpdateInput!, where: IntakeFormValuesWhereUniqueInput!): IntakeFormValues
  updateManyIntakeFormValueses(data: IntakeFormValuesUpdateManyMutationInput!, where: IntakeFormValuesWhereInput): BatchPayload!
  upsertIntakeFormValues(where: IntakeFormValuesWhereUniqueInput!, create: IntakeFormValuesCreateInput!, update: IntakeFormValuesUpdateInput!): IntakeFormValues!
  deleteIntakeFormValues(where: IntakeFormValuesWhereUniqueInput!): IntakeFormValues
  deleteManyIntakeFormValueses(where: IntakeFormValuesWhereInput): BatchPayload!
  createParent(data: ParentCreateInput!): Parent!
  updateParent(data: ParentUpdateInput!, where: ParentWhereUniqueInput!): Parent
  updateManyParents(data: ParentUpdateManyMutationInput!, where: ParentWhereInput): BatchPayload!
  upsertParent(where: ParentWhereUniqueInput!, create: ParentCreateInput!, update: ParentUpdateInput!): Parent!
  deleteParent(where: ParentWhereUniqueInput!): Parent
  deleteManyParents(where: ParentWhereInput): BatchPayload!
  createPermission(data: PermissionCreateInput!): Permission!
  updatePermission(data: PermissionUpdateInput!, where: PermissionWhereUniqueInput!): Permission
  updateManyPermissions(data: PermissionUpdateManyMutationInput!, where: PermissionWhereInput): BatchPayload!
  upsertPermission(where: PermissionWhereUniqueInput!, create: PermissionCreateInput!, update: PermissionUpdateInput!): Permission!
  deletePermission(where: PermissionWhereUniqueInput!): Permission
  deleteManyPermissions(where: PermissionWhereInput): BatchPayload!
  createPhysician(data: PhysicianCreateInput!): Physician!
  updatePhysician(data: PhysicianUpdateInput!, where: PhysicianWhereUniqueInput!): Physician
  updateManyPhysicians(data: PhysicianUpdateManyMutationInput!, where: PhysicianWhereInput): BatchPayload!
  upsertPhysician(where: PhysicianWhereUniqueInput!, create: PhysicianCreateInput!, update: PhysicianUpdateInput!): Physician!
  deletePhysician(where: PhysicianWhereUniqueInput!): Physician
  deleteManyPhysicians(where: PhysicianWhereInput): BatchPayload!
  createReferral(data: ReferralCreateInput!): Referral!
  updateReferral(data: ReferralUpdateInput!, where: ReferralWhereUniqueInput!): Referral
  updateManyReferrals(data: ReferralUpdateManyMutationInput!, where: ReferralWhereInput): BatchPayload!
  upsertReferral(where: ReferralWhereUniqueInput!, create: ReferralCreateInput!, update: ReferralUpdateInput!): Referral!
  deleteReferral(where: ReferralWhereUniqueInput!): Referral
  deleteManyReferrals(where: ReferralWhereInput): BatchPayload!
  createRole(data: RoleCreateInput!): Role!
  updateRole(data: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role
  updateManyRoles(data: RoleUpdateManyMutationInput!, where: RoleWhereInput): BatchPayload!
  upsertRole(where: RoleWhereUniqueInput!, create: RoleCreateInput!, update: RoleUpdateInput!): Role!
  deleteRole(where: RoleWhereUniqueInput!): Role
  deleteManyRoles(where: RoleWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Parent {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  phoneNumber: String!
  email: String!
  isInSameHousehold: Boolean!
  dob: String
  address: Address!
}

type ParentConnection {
  pageInfo: PageInfo!
  edges: [ParentEdge]!
  aggregate: AggregateParent!
}

input ParentCreateInput {
  firstName: String!
  lastName: String!
  phoneNumber: String!
  email: String!
  isInSameHousehold: Boolean!
  dob: String
  address: AddressCreateOneInput!
}

input ParentCreateManyInput {
  create: [ParentCreateInput!]
  connect: [ParentWhereUniqueInput!]
}

type ParentEdge {
  node: Parent!
  cursor: String!
}

enum ParentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  email_ASC
  email_DESC
  isInSameHousehold_ASC
  isInSameHousehold_DESC
  dob_ASC
  dob_DESC
}

type ParentPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  phoneNumber: String!
  email: String!
  isInSameHousehold: Boolean!
  dob: String
}

input ParentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  isInSameHousehold: Boolean
  isInSameHousehold_not: Boolean
  dob: String
  dob_not: String
  dob_in: [String!]
  dob_not_in: [String!]
  dob_lt: String
  dob_lte: String
  dob_gt: String
  dob_gte: String
  dob_contains: String
  dob_not_contains: String
  dob_starts_with: String
  dob_not_starts_with: String
  dob_ends_with: String
  dob_not_ends_with: String
  AND: [ParentScalarWhereInput!]
  OR: [ParentScalarWhereInput!]
  NOT: [ParentScalarWhereInput!]
}

type ParentSubscriptionPayload {
  mutation: MutationType!
  node: Parent
  updatedFields: [String!]
  previousValues: ParentPreviousValues
}

input ParentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ParentWhereInput
  AND: [ParentSubscriptionWhereInput!]
  OR: [ParentSubscriptionWhereInput!]
  NOT: [ParentSubscriptionWhereInput!]
}

input ParentUpdateDataInput {
  firstName: String
  lastName: String
  phoneNumber: String
  email: String
  isInSameHousehold: Boolean
  dob: String
  address: AddressUpdateOneRequiredInput
}

input ParentUpdateInput {
  firstName: String
  lastName: String
  phoneNumber: String
  email: String
  isInSameHousehold: Boolean
  dob: String
  address: AddressUpdateOneRequiredInput
}

input ParentUpdateManyDataInput {
  firstName: String
  lastName: String
  phoneNumber: String
  email: String
  isInSameHousehold: Boolean
  dob: String
}

input ParentUpdateManyInput {
  create: [ParentCreateInput!]
  update: [ParentUpdateWithWhereUniqueNestedInput!]
  upsert: [ParentUpsertWithWhereUniqueNestedInput!]
  delete: [ParentWhereUniqueInput!]
  connect: [ParentWhereUniqueInput!]
  set: [ParentWhereUniqueInput!]
  disconnect: [ParentWhereUniqueInput!]
  deleteMany: [ParentScalarWhereInput!]
  updateMany: [ParentUpdateManyWithWhereNestedInput!]
}

input ParentUpdateManyMutationInput {
  firstName: String
  lastName: String
  phoneNumber: String
  email: String
  isInSameHousehold: Boolean
  dob: String
}

input ParentUpdateManyWithWhereNestedInput {
  where: ParentScalarWhereInput!
  data: ParentUpdateManyDataInput!
}

input ParentUpdateWithWhereUniqueNestedInput {
  where: ParentWhereUniqueInput!
  data: ParentUpdateDataInput!
}

input ParentUpsertWithWhereUniqueNestedInput {
  where: ParentWhereUniqueInput!
  update: ParentUpdateDataInput!
  create: ParentCreateInput!
}

input ParentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  isInSameHousehold: Boolean
  isInSameHousehold_not: Boolean
  dob: String
  dob_not: String
  dob_in: [String!]
  dob_not_in: [String!]
  dob_lt: String
  dob_lte: String
  dob_gt: String
  dob_gte: String
  dob_contains: String
  dob_not_contains: String
  dob_starts_with: String
  dob_not_starts_with: String
  dob_ends_with: String
  dob_not_ends_with: String
  address: AddressWhereInput
  AND: [ParentWhereInput!]
  OR: [ParentWhereInput!]
  NOT: [ParentWhereInput!]
}

input ParentWhereUniqueInput {
  id: ID
}

type Permission {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  roles(where: RoleWhereInput, orderBy: RoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Role!]
}

type PermissionConnection {
  pageInfo: PageInfo!
  edges: [PermissionEdge]!
  aggregate: AggregatePermission!
}

input PermissionCreateInput {
  name: String!
  roles: RoleCreateManyWithoutPermissionsInput
}

input PermissionCreateManyWithoutRolesInput {
  create: [PermissionCreateWithoutRolesInput!]
  connect: [PermissionWhereUniqueInput!]
}

input PermissionCreateWithoutRolesInput {
  name: String!
}

type PermissionEdge {
  node: Permission!
  cursor: String!
}

enum PermissionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
}

type PermissionPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
}

input PermissionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [PermissionScalarWhereInput!]
  OR: [PermissionScalarWhereInput!]
  NOT: [PermissionScalarWhereInput!]
}

type PermissionSubscriptionPayload {
  mutation: MutationType!
  node: Permission
  updatedFields: [String!]
  previousValues: PermissionPreviousValues
}

input PermissionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PermissionWhereInput
  AND: [PermissionSubscriptionWhereInput!]
  OR: [PermissionSubscriptionWhereInput!]
  NOT: [PermissionSubscriptionWhereInput!]
}

input PermissionUpdateInput {
  name: String
  roles: RoleUpdateManyWithoutPermissionsInput
}

input PermissionUpdateManyDataInput {
  name: String
}

input PermissionUpdateManyMutationInput {
  name: String
}

input PermissionUpdateManyWithoutRolesInput {
  create: [PermissionCreateWithoutRolesInput!]
  delete: [PermissionWhereUniqueInput!]
  connect: [PermissionWhereUniqueInput!]
  set: [PermissionWhereUniqueInput!]
  disconnect: [PermissionWhereUniqueInput!]
  update: [PermissionUpdateWithWhereUniqueWithoutRolesInput!]
  upsert: [PermissionUpsertWithWhereUniqueWithoutRolesInput!]
  deleteMany: [PermissionScalarWhereInput!]
  updateMany: [PermissionUpdateManyWithWhereNestedInput!]
}

input PermissionUpdateManyWithWhereNestedInput {
  where: PermissionScalarWhereInput!
  data: PermissionUpdateManyDataInput!
}

input PermissionUpdateWithoutRolesDataInput {
  name: String
}

input PermissionUpdateWithWhereUniqueWithoutRolesInput {
  where: PermissionWhereUniqueInput!
  data: PermissionUpdateWithoutRolesDataInput!
}

input PermissionUpsertWithWhereUniqueWithoutRolesInput {
  where: PermissionWhereUniqueInput!
  update: PermissionUpdateWithoutRolesDataInput!
  create: PermissionCreateWithoutRolesInput!
}

input PermissionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  roles_every: RoleWhereInput
  roles_some: RoleWhereInput
  roles_none: RoleWhereInput
  AND: [PermissionWhereInput!]
  OR: [PermissionWhereInput!]
  NOT: [PermissionWhereInput!]
}

input PermissionWhereUniqueInput {
  id: ID
}

type Physician {
  id: ID!
  firstName: String!
  lastName: String!
  practice: String!
  phoneNumber: String!
}

type PhysicianConnection {
  pageInfo: PageInfo!
  edges: [PhysicianEdge]!
  aggregate: AggregatePhysician!
}

input PhysicianCreateInput {
  firstName: String!
  lastName: String!
  practice: String!
  phoneNumber: String!
}

input PhysicianCreateOneInput {
  create: PhysicianCreateInput
  connect: PhysicianWhereUniqueInput
}

type PhysicianEdge {
  node: Physician!
  cursor: String!
}

enum PhysicianOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  practice_ASC
  practice_DESC
  phoneNumber_ASC
  phoneNumber_DESC
}

type PhysicianPreviousValues {
  id: ID!
  firstName: String!
  lastName: String!
  practice: String!
  phoneNumber: String!
}

type PhysicianSubscriptionPayload {
  mutation: MutationType!
  node: Physician
  updatedFields: [String!]
  previousValues: PhysicianPreviousValues
}

input PhysicianSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhysicianWhereInput
  AND: [PhysicianSubscriptionWhereInput!]
  OR: [PhysicianSubscriptionWhereInput!]
  NOT: [PhysicianSubscriptionWhereInput!]
}

input PhysicianUpdateDataInput {
  firstName: String
  lastName: String
  practice: String
  phoneNumber: String
}

input PhysicianUpdateInput {
  firstName: String
  lastName: String
  practice: String
  phoneNumber: String
}

input PhysicianUpdateManyMutationInput {
  firstName: String
  lastName: String
  practice: String
  phoneNumber: String
}

input PhysicianUpdateOneRequiredInput {
  create: PhysicianCreateInput
  update: PhysicianUpdateDataInput
  upsert: PhysicianUpsertNestedInput
  connect: PhysicianWhereUniqueInput
}

input PhysicianUpsertNestedInput {
  update: PhysicianUpdateDataInput!
  create: PhysicianCreateInput!
}

input PhysicianWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  practice: String
  practice_not: String
  practice_in: [String!]
  practice_not_in: [String!]
  practice_lt: String
  practice_lte: String
  practice_gt: String
  practice_gte: String
  practice_contains: String
  practice_not_contains: String
  practice_starts_with: String
  practice_not_starts_with: String
  practice_ends_with: String
  practice_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  AND: [PhysicianWhereInput!]
  OR: [PhysicianWhereInput!]
  NOT: [PhysicianWhereInput!]
}

input PhysicianWhereUniqueInput {
  id: ID
}

type Query {
  address(where: AddressWhereUniqueInput!): Address
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address]!
  addressesConnection(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressConnection!
  client(where: ClientWhereUniqueInput!): Client
  clients(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Client]!
  clientsConnection(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClientConnection!
  clientIntake(where: ClientIntakeWhereUniqueInput!): ClientIntake
  clientIntakes(where: ClientIntakeWhereInput, orderBy: ClientIntakeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClientIntake]!
  clientIntakesConnection(where: ClientIntakeWhereInput, orderBy: ClientIntakeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClientIntakeConnection!
  concerns(where: ConcernsWhereUniqueInput!): Concerns
  concernses(where: ConcernsWhereInput, orderBy: ConcernsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Concerns]!
  concernsesConnection(where: ConcernsWhereInput, orderBy: ConcernsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ConcernsConnection!
  diagnosis(where: DiagnosisWhereUniqueInput!): Diagnosis
  diagnoses(where: DiagnosisWhereInput, orderBy: DiagnosisOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Diagnosis]!
  diagnosesConnection(where: DiagnosisWhereInput, orderBy: DiagnosisOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DiagnosisConnection!
  insurance(where: InsuranceWhereUniqueInput!): Insurance
  insurances(where: InsuranceWhereInput, orderBy: InsuranceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Insurance]!
  insurancesConnection(where: InsuranceWhereInput, orderBy: InsuranceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InsuranceConnection!
  intakeFormQuestions(where: IntakeFormQuestionsWhereUniqueInput!): IntakeFormQuestions
  intakeFormQuestionses(where: IntakeFormQuestionsWhereInput, orderBy: IntakeFormQuestionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [IntakeFormQuestions]!
  intakeFormQuestionsesConnection(where: IntakeFormQuestionsWhereInput, orderBy: IntakeFormQuestionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IntakeFormQuestionsConnection!
  intakeFormValues(where: IntakeFormValuesWhereUniqueInput!): IntakeFormValues
  intakeFormValueses(where: IntakeFormValuesWhereInput, orderBy: IntakeFormValuesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [IntakeFormValues]!
  intakeFormValuesesConnection(where: IntakeFormValuesWhereInput, orderBy: IntakeFormValuesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IntakeFormValuesConnection!
  parent(where: ParentWhereUniqueInput!): Parent
  parents(where: ParentWhereInput, orderBy: ParentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Parent]!
  parentsConnection(where: ParentWhereInput, orderBy: ParentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ParentConnection!
  permission(where: PermissionWhereUniqueInput!): Permission
  permissions(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Permission]!
  permissionsConnection(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PermissionConnection!
  physician(where: PhysicianWhereUniqueInput!): Physician
  physicians(where: PhysicianWhereInput, orderBy: PhysicianOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Physician]!
  physiciansConnection(where: PhysicianWhereInput, orderBy: PhysicianOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhysicianConnection!
  referral(where: ReferralWhereUniqueInput!): Referral
  referrals(where: ReferralWhereInput, orderBy: ReferralOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Referral]!
  referralsConnection(where: ReferralWhereInput, orderBy: ReferralOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReferralConnection!
  role(where: RoleWhereUniqueInput!): Role
  roles(where: RoleWhereInput, orderBy: RoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Role]!
  rolesConnection(where: RoleWhereInput, orderBy: RoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoleConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Referral {
  id: ID!
  firstName: String!
  lastName: String!
}

type ReferralConnection {
  pageInfo: PageInfo!
  edges: [ReferralEdge]!
  aggregate: AggregateReferral!
}

input ReferralCreateInput {
  firstName: String!
  lastName: String!
}

input ReferralCreateOneInput {
  create: ReferralCreateInput
  connect: ReferralWhereUniqueInput
}

type ReferralEdge {
  node: Referral!
  cursor: String!
}

enum ReferralOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
}

type ReferralPreviousValues {
  id: ID!
  firstName: String!
  lastName: String!
}

type ReferralSubscriptionPayload {
  mutation: MutationType!
  node: Referral
  updatedFields: [String!]
  previousValues: ReferralPreviousValues
}

input ReferralSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReferralWhereInput
  AND: [ReferralSubscriptionWhereInput!]
  OR: [ReferralSubscriptionWhereInput!]
  NOT: [ReferralSubscriptionWhereInput!]
}

input ReferralUpdateDataInput {
  firstName: String
  lastName: String
}

input ReferralUpdateInput {
  firstName: String
  lastName: String
}

input ReferralUpdateManyMutationInput {
  firstName: String
  lastName: String
}

input ReferralUpdateOneInput {
  create: ReferralCreateInput
  update: ReferralUpdateDataInput
  upsert: ReferralUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ReferralWhereUniqueInput
}

input ReferralUpsertNestedInput {
  update: ReferralUpdateDataInput!
  create: ReferralCreateInput!
}

input ReferralWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  AND: [ReferralWhereInput!]
  OR: [ReferralWhereInput!]
  NOT: [ReferralWhereInput!]
}

input ReferralWhereUniqueInput {
  id: ID
}

type Role {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  permissions(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Permission!]
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

type RoleConnection {
  pageInfo: PageInfo!
  edges: [RoleEdge]!
  aggregate: AggregateRole!
}

input RoleCreateInput {
  name: String!
  permissions: PermissionCreateManyWithoutRolesInput
  users: UserCreateManyWithoutRolesInput
}

input RoleCreateManyWithoutPermissionsInput {
  create: [RoleCreateWithoutPermissionsInput!]
  connect: [RoleWhereUniqueInput!]
}

input RoleCreateManyWithoutUsersInput {
  create: [RoleCreateWithoutUsersInput!]
  connect: [RoleWhereUniqueInput!]
}

input RoleCreateWithoutPermissionsInput {
  name: String!
  users: UserCreateManyWithoutRolesInput
}

input RoleCreateWithoutUsersInput {
  name: String!
  permissions: PermissionCreateManyWithoutRolesInput
}

type RoleEdge {
  node: Role!
  cursor: String!
}

enum RoleOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
}

type RolePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
}

input RoleScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [RoleScalarWhereInput!]
  OR: [RoleScalarWhereInput!]
  NOT: [RoleScalarWhereInput!]
}

type RoleSubscriptionPayload {
  mutation: MutationType!
  node: Role
  updatedFields: [String!]
  previousValues: RolePreviousValues
}

input RoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoleWhereInput
  AND: [RoleSubscriptionWhereInput!]
  OR: [RoleSubscriptionWhereInput!]
  NOT: [RoleSubscriptionWhereInput!]
}

input RoleUpdateInput {
  name: String
  permissions: PermissionUpdateManyWithoutRolesInput
  users: UserUpdateManyWithoutRolesInput
}

input RoleUpdateManyDataInput {
  name: String
}

input RoleUpdateManyMutationInput {
  name: String
}

input RoleUpdateManyWithoutPermissionsInput {
  create: [RoleCreateWithoutPermissionsInput!]
  delete: [RoleWhereUniqueInput!]
  connect: [RoleWhereUniqueInput!]
  set: [RoleWhereUniqueInput!]
  disconnect: [RoleWhereUniqueInput!]
  update: [RoleUpdateWithWhereUniqueWithoutPermissionsInput!]
  upsert: [RoleUpsertWithWhereUniqueWithoutPermissionsInput!]
  deleteMany: [RoleScalarWhereInput!]
  updateMany: [RoleUpdateManyWithWhereNestedInput!]
}

input RoleUpdateManyWithoutUsersInput {
  create: [RoleCreateWithoutUsersInput!]
  delete: [RoleWhereUniqueInput!]
  connect: [RoleWhereUniqueInput!]
  set: [RoleWhereUniqueInput!]
  disconnect: [RoleWhereUniqueInput!]
  update: [RoleUpdateWithWhereUniqueWithoutUsersInput!]
  upsert: [RoleUpsertWithWhereUniqueWithoutUsersInput!]
  deleteMany: [RoleScalarWhereInput!]
  updateMany: [RoleUpdateManyWithWhereNestedInput!]
}

input RoleUpdateManyWithWhereNestedInput {
  where: RoleScalarWhereInput!
  data: RoleUpdateManyDataInput!
}

input RoleUpdateWithoutPermissionsDataInput {
  name: String
  users: UserUpdateManyWithoutRolesInput
}

input RoleUpdateWithoutUsersDataInput {
  name: String
  permissions: PermissionUpdateManyWithoutRolesInput
}

input RoleUpdateWithWhereUniqueWithoutPermissionsInput {
  where: RoleWhereUniqueInput!
  data: RoleUpdateWithoutPermissionsDataInput!
}

input RoleUpdateWithWhereUniqueWithoutUsersInput {
  where: RoleWhereUniqueInput!
  data: RoleUpdateWithoutUsersDataInput!
}

input RoleUpsertWithWhereUniqueWithoutPermissionsInput {
  where: RoleWhereUniqueInput!
  update: RoleUpdateWithoutPermissionsDataInput!
  create: RoleCreateWithoutPermissionsInput!
}

input RoleUpsertWithWhereUniqueWithoutUsersInput {
  where: RoleWhereUniqueInput!
  update: RoleUpdateWithoutUsersDataInput!
  create: RoleCreateWithoutUsersInput!
}

input RoleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  permissions_every: PermissionWhereInput
  permissions_some: PermissionWhereInput
  permissions_none: PermissionWhereInput
  users_every: UserWhereInput
  users_some: UserWhereInput
  users_none: UserWhereInput
  AND: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
}

input RoleWhereUniqueInput {
  id: ID
}

type Subscription {
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
  client(where: ClientSubscriptionWhereInput): ClientSubscriptionPayload
  clientIntake(where: ClientIntakeSubscriptionWhereInput): ClientIntakeSubscriptionPayload
  concerns(where: ConcernsSubscriptionWhereInput): ConcernsSubscriptionPayload
  diagnosis(where: DiagnosisSubscriptionWhereInput): DiagnosisSubscriptionPayload
  insurance(where: InsuranceSubscriptionWhereInput): InsuranceSubscriptionPayload
  intakeFormQuestions(where: IntakeFormQuestionsSubscriptionWhereInput): IntakeFormQuestionsSubscriptionPayload
  intakeFormValues(where: IntakeFormValuesSubscriptionWhereInput): IntakeFormValuesSubscriptionPayload
  parent(where: ParentSubscriptionWhereInput): ParentSubscriptionPayload
  permission(where: PermissionSubscriptionWhereInput): PermissionSubscriptionPayload
  physician(where: PhysicianSubscriptionWhereInput): PhysicianSubscriptionPayload
  referral(where: ReferralSubscriptionWhereInput): ReferralSubscriptionPayload
  role(where: RoleSubscriptionWhereInput): RoleSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  email: String!
  roles(where: RoleWhereInput, orderBy: RoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Role!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  firstName: String!
  lastName: String!
  email: String!
  roles: RoleCreateManyWithoutUsersInput
}

input UserCreateManyWithoutRolesInput {
  create: [UserCreateWithoutRolesInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateWithoutRolesInput {
  firstName: String!
  lastName: String!
  email: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  email_ASC
  email_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  email: String!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  firstName: String
  lastName: String
  email: String
  roles: RoleUpdateManyWithoutUsersInput
}

input UserUpdateManyDataInput {
  firstName: String
  lastName: String
  email: String
}

input UserUpdateManyMutationInput {
  firstName: String
  lastName: String
  email: String
}

input UserUpdateManyWithoutRolesInput {
  create: [UserCreateWithoutRolesInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutRolesInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutRolesInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateWithoutRolesDataInput {
  firstName: String
  lastName: String
  email: String
}

input UserUpdateWithWhereUniqueWithoutRolesInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutRolesDataInput!
}

input UserUpsertWithWhereUniqueWithoutRolesInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutRolesDataInput!
  create: UserCreateWithoutRolesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  roles_every: RoleWhereInput
  roles_some: RoleWhereInput
  roles_none: RoleWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`
      }
    